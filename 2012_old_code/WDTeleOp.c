#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,          tube,          tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          rackPinion,    tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorRight,    tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorLeft,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorRamp,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     motorE,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_2,    ringPlacer,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_1,    elServo,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*// v

//RP = ringPlacer
//ES= elServo

#include "JoystickDriver.c"
#define RP_POSITION_1 60
#define ES_POSITION_1 201
#define RP_POSITION_2 255
#define ES_POSITION_2 72
#define RP_POSITION_3 156
#define RACK_ALIGN_POSITION 1500

bool trapSet = true;
bool go = false;

void drival(int right, int left)
{
	motor[motorRight] = right;
	motor[motorLeft] = left;
}

void gostraight(int encoder, int speed) {
	nMotorEncoder[motorRight] = 0;
	while(true)
	{
		if (encoder > abs(nMotorEncoder[motorRight]))
			drival(speed, speed);
		if (encoder <= abs(nMotorEncoder[motorRight]))
			break;
	}
	drival(0,0);
}

void turnleft(int encoder, int speed) {
	nMotorEncoder[motorRight] = 0;
	while(true) {
		if (encoder > abs(nMotorEncoder[motorRight]))
			drival(speed, 0);
		if (encoder <= abs(nMotorEncoder[motorRight]))
			break;
	}
	drival(0,0);
}

void turnright (int encoder, int speed) {
	nMotorEncoder[motorLeft]=0;
	while(true)
	{
		if (abs(encoder) > abs(nMotorEncoder[motorLeft]))
			drival(0, speed);
		if (abs(encoder) <= abs(nMotorEncoder[motorLeft]))
			break;
	}
	drival(0,0);
}


task main()
{
	servo[ringPlacer] = RP_POSITION_1;
	servo[elServo] = ES_POSITION_1;
	waitForStart();
	nMotorEncoder[rackPinion] = 0;

	while(1==1)
	{
		servoChangeRate[ringPlacer] = 4;
		servoChangeRate[elServo] = 2;
		motor[motorLeft] = ((35.0)*(joystick.joy1_y1/127.0)*(joystick.joy1_y1/127.0)*(joystick.joy1_y1/127.0));
 		motor[motorRight] = ((100.0)*(joystick.joy1_y2/127.0)*(joystick.joy1_y2/127.0)*(joystick.joy1_y2/127.0));
		motor[rackPinion] = -((100.0)*(joystick.joy2_y1/127.0)*(joystick.joy2_y1/127.0)*(joystick.joy2_y1/127.0));
	  motor[tube] = ((100.0)*(joystick.joy2_y2/127.0)*(joystick.joy2_y2/127.0)*(joystick.joy2_y2/127.0));

	  if(joystick.joy1_TopHat == 2)
	  {
	  	turnright(150, 80);
			turnleft(150, 80);
	  }
	 	if(joystick.joy1_TopHat == 6)
	 	{
	 		turnleft(150, 80);
			turnright(150, 80);
	 	}

		if(joy2Btn(2))
		{
			servo[ringPlacer] = ServoValue[ringPlacer] - 1;
		}
		else if(joy2Btn(1))
		{
			servo[ringPlacer] = ServoValue[ringPlacer] + 1;
		}
		if(joy2Btn(4))
		{
			servo[elServo] = ServoValue[elServo] - 1;
		}
		else if(joy2Btn(3))
		{
			servo[elServo] = ServoValue[elServo] + 1;
		}
		if(joy2Btn(5))
		{
			servo[ringPlacer] = RP_POSITION_1;
			servo[elServo] = ES_POSITION_1;
		}
		if(joy2Btn(6))
		{
			servo[elServo] = 0;
			/*if(ServoValue[ringPlacer] > 120)
			{
				servo[elServo] = ES_POSITION_2;
			}
			servo[ringPlacer] = RP_POSITION_2;*/
		}
		if(joy2Btn(8))
		{
			servo[elServo] = 255;
			//servo[ringPlacer] = RP_POSITION_3;
		}
		if(joy1Btn(2))
		{
			motor[motorRamp] = 10;
		}
		else if(joy1Btn(1))
		{
			motor[motorRamp] = -100;
		}
		else
		{
			motor[motorRamp] = 0;
		}
		if(trapSet)
		{
			if(joystick.joy2_TopHat == 0)
			{
				go = true;
				trapSet = false;
			}
		}
		if(go)
		{
			if(abs(nMotorEncoder[rackPinion]) < RACK_ALIGN_POSITION)
			{
				motor[rackPinion] = -100; // move forward
			}
			else
			{
				trapSet = true;
				go = false;
			}

			//nxtDisplayTextLine(1, sFormatString, ...);
		}
		if(joy1Btn(5))
		{
			motor[motorLeft] = 50;
		}
		else if(joy1Btn(7))
		{
			motor[motorLeft] = -50;
		}
		if(joy1Btn(6))
		{
			motor[motorRight] = 50;
		}
		else if(joy1Btn(8))
		{
			motor[motorRight] = -50;
		}
		else
		{
			motor[motorLeft] = ((100.0)*(joystick.joy1_y1/127.0)*(joystick.joy1_y1/127.0)*(joystick.joy1_y1/127.0));
 			motor[motorRight] = ((100.0)*(joystick.joy1_y2/127.0)*(joystick.joy1_y2/127.0)*(joystick.joy1_y2/127.0));
		}

	}
}
