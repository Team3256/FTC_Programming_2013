 #pragma config(Sensor, S1,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S3,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     touchSensor,    sensorTouch)
#pragma config(Motor,  motorA,          arm,           tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightWheel,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftWheel,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Autonomous Mode Code Template
//
// This file contains a template for simplified creation of an autonomous program for an TETRIX robot
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////


float pie = 3.14159;
float track = 5.9;
float halfTrack=track/2;
float wheelDiam=2.356;
float wheelRadius = wheelDiam/2;
float wheelCircumference=wheelDiam*pie;
float ticksPerInches = 360/wheelCircumference;
float halfRobotCircumference = track*pie;
float robotCircumference = track*2*pie;
float inchesPerDegreeOneWheel = wheelCircumference/robotCircumference;
float inchesPerDegreeTwoWheel = wheelCircumference/halfRobotCircumference;

int getIrReading(tSensors irReceiverPin)
{
  // IRLED 38 kHz for at least 2 ms
  wait1Msec(1);                              // Wait 1 ms
  int ir = SensorValue[irReceiverPin];      // IR receiver -> ir variable
  wait1Msec(1);                              // Down time before recheck
  return ir;
}




void straight(float inchesMoved, int motorSpeed){
	float nticks = 0;
	nticks =  abs(inchesMoved *ticksPerInches);
	nMotorEncoder[motorC] = 0;
	while(abs(nMotorEncoder[motorC]) < nticks){
		motor[motorC] = motorSpeed;
		motor[motorB] = motorSpeed;

	}
}
void irTest()
{
	//while(true ){
	int irTest= false;
	/*straight(47, 50);
	motor[motorB] = 0;
	motor[motorC] = 0;
	wait10Msec(100);
	while(irTest ==false){

		if (SensorValue[irSensor]== 5) {
    	  //there is something within the threshold range
     	 motor[motorB] = 0;
     	 motor[motorC]=0;

    }
    else
    {

    	motor[motorB]=50;
    	motor[motorC]=50;
    }
	}*/
	motor[motorA] = -50;
	wait10Msec(200);
	if(SensorValue[irSensor]==5){

		motor[motorA]=50;
		wait10Msec(500);

	}	else{
		motor[motorA]=0;

	}



//}
}

void leftHalfTrackTurn(int degreesMoved){
	float nticks =0;
	nticks = abs((degreesMoved*halfTrack)/wheelRadius);

	nMotorEncoder[motorC]=0;
	while(nMotorEncoder[motorC] < nticks){
		motor[motorC] = 40;
		motor[motorB] = -40;

	}
	nticks =0;
}
void  rightHalfTrackTurn(int degreesMoved){
	float nticks = 0;
	nticks = abs((degreesMoved*halfTrack)/wheelRadius);
	nMotorEncoder[motorB]=0;
	while(nMotorEncoder[motorB] < nticks){
		motor[motorC] = -40;
		motor[motorB] = 40;
	}

}

void touch(){
	while(SensorValue(touchSensor)!=5){
		motor[motorC] = 10;
			motor[motorB] = 10;
	}

	if(SensorValue(touchSensor)==5){
		motor[motorA]=50;
		wait10Msec(100);
	}
}

void light(){

	while(SensorValue(lightSensor)>10){
			motor[motorC] = 10;
			motor[motorB] = 10;
		}

	if(sensorValue(lightSensor)<=10){
		touch();
	}
}
void  arm1(int degreesMoved){
	float nticks = 0;
	nticks = abs((degreesMoved*halfTrack)/wheelRadius);
	nMotorEncoder[motorA]=0;
	while(nMotorEncoder[motorA] < nticks){
		motor[motorA] = degreesMoved;

	}

}
void trip1(){

	straight(19, 75);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
  leftHalfTrackTurn(87.5);
 motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(16, 75);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	rightHalfTrackTurn(85);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(39, 75);

	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(5.4, 10);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(17.5, -75);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	leftHalfTrackTurn(81);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(4, 35);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	light();
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(15, -50);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	rightHalfTrackTurn(20);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(22.5, 50);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(19,-50);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	leftHalfTrackTurn(107);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(27.75,75);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	leftHalfTrackTurn(86.5);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(15,65);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	rightHalfTrackTurn(89);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(500);
	straight(11,60);
	motor[motorB]=0;
	motor[motorC]=0;
	wait1Msec(30000);



  }

void trip2(){
straight(11,80);
rightHalfTrackTurn(90);
straight(34,90);
leftHalfTrackTurn(11);
straight(40,90);
leftHalfTrackTurn(135);
straight(50,90);
straight(12,-90);
leftHalfTrackTurn(90);
straight(37,90);

}
task main()
{


	//straight(19);

	//trip1();
	irTest();
	//trip2();
   // Wait for the beginning of autonomous phase.

  ///////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////
  ////                                                   ////
  ////    Add your robot specific autonomous code here.  ////
  ////                                                   ////
  ///////////////////////////////////////////////////////////
}
